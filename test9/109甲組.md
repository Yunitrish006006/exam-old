# 109 甲組

1.Memory addressing
Consider the following MIPS code segment. Initially, the memory contents are given as follows.Assume that the content of \$t1 and \$t2 are 3000 and 3004, respectively. Show the step-by-step operation taken by each instruction in the following code segment.

- lw $s1,0($t1)
- sub $s2, $s2, $s2
- add $s2,$2,100
- lw $s1,0($s1)
- add Ss1.$sl,$s2
- lw $s3,0($t2)
- add $s3 $s3,$s2
- SW $s3,4($s1)
- SW $s1,0($sl)

![1.png](1.png)

詳解:

    lw $s1,0($t1)
    - Load the value from memory address 3000 (the value of register $t1) into register $s1.

    sub $s2, $s2, $s2 (s2 = 0)
    - Subtract register $s2 from itself and store the result in register $s2. This effectively clears register $s2 to zero.
    
    add $s2,$2,100
    - Add 100 to register $s2.
    
    lw $s1,0($s1)
    - Load the value from memory address stored in register $s1 into register $s1.
    
    add $s1,$sl,$s2
    - Add register $s2 to the value stored in register $s1 and store the result in register $s1.
    
    lw $s3,0($t2)
    - Load the value from memory address 3004 (the value of register $t2) into register $s3.
    
    add $s3 $s3,$s2
    - Add register $s2 to the value stored in register $s3 and store the result in register $s3.
    
    SW $s3,4($s1)
    - Store the value stored in register $s3 to memory address 4 bytes offset from the value stored in register $s1.
    
    SW $s1,0($sl)
    - Store the value stored in register $s1 to memory address 0 (the value of register $sl).

    $s1: 3100

    $s2: 100

    $s3: 3104

    $t1: 3000

    $t2: 3004

2.There are three types of MIPS instructions: R-type, I-type, and J-type. The instruction formats are given below.

![2.png](2.png)

- (a) Decide what is the maximum ranges of (i) immediate, (ii) displacement, and (iii) PC-relative branch.

    詳解:

      Immediate: The maximum range of an immediate in MIPS is 2^16, or 65536. This is because the immediate field in I-type instructions is 16 bits wide.

      Displacement: The maximum range of a displacement in MIPS is 2^16 - 4, or 65532. This is because the displacement field in I-type instructions is 16 bits wide, and the offset to the base address is always word-aligned.

      PC-relative branch: The maximum range of a PC-relative branch in MIPS is 2^20 - 8, or 1048560. This is because the offset field in J-type instructions is 20 bits wide, and the offset to the target address is always word-aligned.

- (b) Consider the following three instructions. What are the types of them?
  - (i) sub \$s2, \$s2,$s2 #subtraction

        R-type
  - (ii) $s1,100($s1) #load word

        I-type
  - (iii) beq \$s0,$1,Exit #branch to Exit if \$s0 = $1

        J-type

3.Memory system
In a virtual memory system, it takes 10 ns to access a word in the cache. If a word is in main memory
but not in the cache, 30 ns are needed to load it into the cache, and then the reference to it is started
again. If the word is not in main memory, 12 ms are required to fetch the word from disc, followed by
30ns to copy it to the cache, and then the reference is started again.

- (a) Let the cache hit ratio be 0.9 and the main-memory hit ratio be 0.6. What is the average time
(in ns) to access a referenced word in the system?

詳解:

  Location | Hit Ratio | Access Time | Average Time |
  :-:|:-:|:-:|:-:|
  Cache | 0.9 | 10 ns | 9 ns |
  Main Memory | 0.6 | 30 ns + 10 ns = 40 ns | 24 ns |
  Disc | 0.1 | 12 ms + 30 ns + 10 ns = 12.03 ms | 1.203 ms |

    Average Access Time

    = (0.9 \* 9 ns) + (0.6 \* 24 ns) + (0.1 \* 1.203 ms)

    = 8.1 ns + 14.4 ns + 120.3 ns

    = 142.8 ns

- (b) The operating system can improve the CPU utilization by trying to do something else other than
idle for 12 ms to wait for the required data to be load from disc to the main memory. Explain how this
process works.

詳解:

    當CPU需要存取一格不再記憶體的字時。他需要等作業系統去拿資料，那這樣就會因為硬碟不斷存取而變得很慢。
    
    所以我們可以用context switch，並將該工作的階段凍結，並執行其他工作，當硬碟存到資料時，再將工作切換回來繼續執行。

4.Arithmetic
(a)  The 32-bit words in registers $s1 and $s2 are given below:

\$s1: 0100 0000 0000 0000 0000 0000 0000 0000

\$s2: 0111 1111 1111 1111 1111 1111 1111 1111

What are the results of executing the following instructions? Explain your answer.

addu \$s3, \$s1, \$s2

add \$s4, \$s1, \$s2

詳解:

because

addu: unsigned addition

add: addition

so

addu $s3, $s1, $s2: $s3 = 2^31 - 1

add $s4, $s1, $s2: $s4 = -1

(b)  The addition operation is execued by an adder. A. 1-bit full adder takes three i-bit inputs (a, b, CarryIn) and produces a 2-bit outputs (CarryOut, Sum) representing sum of the input bits. A 32-bit adder can
be constructed by cascating 32 1-bit full adders. Write down the logic function of CarryOut and Sum.

5.Given the value printed by the following code fragments:

- int resultA = (0 + 15) / 2;
- double resultB = 2.0e-6 * 100000000.1;
- boolean resultC = true && false || true && true;
- System.out.println("(a)" + resultA);
- System.out.prilnth("(b) " + resultB);
- System.out.println("(c) " + resultC);

(a)7
(b)200.0
(c)true

6.What is the outcome for the following recursive function when Test(3):

- Test (int n) {
  - String s = Test(n-3) + n + Test(n-2) + n;
  - If (n<=0) return "";
  - Return S;
- }
Test(3)
= Test(0)3Test(1)3
= 3Test(-2)1Test(-1)13
= 3113

7.Please show that the sink-based Heap construction uses  <=2N compares and <=N exchanges

詳解【bard】:

堆排序是一種非常高效的排序算法，它利用堆的性質來將數據排序。堆排序的核心是堆的構造，而堆的構造通常採用「下沉」的方法。

下沉的過程是將堆的最後一個元素（也就是根元素）與其子節點進行比較，如果子節點的值比根元素大，則將子節點與根元素進行交換。然後，將根元素的值更新為子節點的值，並將子節點作為新的根元素繼續進行下沉。

下沉的過程需要進行比較和交換兩種操作。比較操作是用來確定子節點是否比根元素大。交換操作是用來將子節點與根元素進行交換。

要證明下沉-基於的堆構造使用 <=2N 次比較和 <=N 次交換，我們可以進行如下分析：

對於一個大小為 N 的堆，下沉過程需要進行 N 次下沉操作。
每一次下沉操作最多需要進行一次比較和一次交換。
因此，下沉過程最多需要進行 N 次比較和 N 次交換。
但是，在實際情況中，下沉過程的比較次數可能會小於 N。這是因為，如果子節點的值不比根元素大，則不需要進行交換。因此，下沉過程的比較次數最多為 N。

同理，下沉過程的交換次數最多為 N。

因此，下沉-基於的堆構造使用 <=2N 次比較和 <=N 次交換。

具體的證明如下：

假設堆的大小為 N，則下沉過程需要進行 N 次下沉操作。

每一次下沉操作，如果子節點的值比根元素小或等於，則不需要進行交換。因此，每一次下沉操作最多需要進行一次比較和一次交換。

因此，下沉過程最多需要進行 N 次比較和 N 次交換。

但是，在實際情況中，下沉過程的比較次數可能會小於 N。這是因為，如果子節點的值不比根元素大，則不需要進行交換。因此，下沉過程的比較次數最多為 N。

同理，下沉過程的交換次數最多為 N。

因此，下沉-基於的堆構造使用 <=2N 次比較和 <=N 次交換。
